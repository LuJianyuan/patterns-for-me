## <center> 行为型 - 观察者（Observer）设计模式
---

<div align="center">
   <img src="/doc/resource/observer/Don't-call-us.png" width="50%"/>
</div>

在《编程导论（Java）》一书中，有一句非常著名的好莱坞法则：Don't call us, we'll call you。这原本是在描述 Java 语言的回调机制的，我暂且将其引用在此处，因为这句话所包含的思想与观察者模式的理念不谋而合。以下，我将通过一个例子展开讨论观察者模式。

# 一、问题引入

> 我有一个邻居张婶，她们家在吃水果这一方面有一个癖好，总是讲究尝个新鲜。我家附件有一个水果店，她总是希望能吃到那家水果店中刚上架的水果。

这个问题并不复杂，麻烦的地方在于水果店送来了新鲜的水果，但是张婶并不知道。也许等到张婶去到店里，水果已不再新鲜。所以，张婶记了一个水果店老板的电话号码，每天的 10 点和 22 点打电话问老板有没有到新的水果。有一天的 22 点，老板告诉她，上午 11 左右来了一批水果，但是这会儿已经不够新鲜了。张婶认为是自己询问的不够频繁，所以打算第二天开始每隔 4 个小时询问一次。这下老板直接发火了，一天接到张婶的好几个电话。对老板来说，更烦的是像张婶这样的情况还不是个例，附近的学校食堂、餐厅以及奶茶店每天都会给他打很多个电话询问有没有新鲜上架的水果。

在上面的描述中，张婶、附近的学校食堂、餐厅以及奶茶店都会给老板打电话查问，每天老板都会接到多个没有任何必要的电话，真正有意义的电话仅仅是刚好有水果上新时接到的电话。这无疑造成了大量的资源耗费。对于老板来说，不停的接听电话也是一种折磨。

# 二、解决方案

> 老板不愿意每天接到如此多的查问电话，所以，这一次张婶打电话过去时，老板斩钉截铁的告诉张婶：别再打电话问我了，等我这到了新鲜水果我会打电话通知你的！

这正好和我们在开篇中提到的`Don't call us, we'll call you`呼应了起来，那么我们该如何描述这个过程中的所有行为呢？首先，我们应分析一下，整个过程中包含了哪些角色以及存在哪些行为。

- **水果店**：水果店作为整个过程的枢纽，至少应包含如下几个行为：
   1. **登记**：像张婶这样的顾客，他们希望在水果店上新时通知自己，就得告诉水果店自己的这个期望，以后如果有新的顾客同样希望通知自己，只需要将自己的电话号码登记到水果店的通知列表中；
   1. **注销**：如果顾客在一段时间后，不希望再接收通知时，得告知水果店以后不要再通知自己。比如，顾客搬家到离水果店很远的地方时，此时的通知电话对用户来说就是打扰；
   1. **上新**：供应商运送了新鲜的水果到水果店里；
   1. **通知**：老板按照通知列表中的用户，一个一个的打电话通知他们店里刚刚上新。
- **顾客**：顾客是整个过程的末端，应该包含有如下的行为：
   1. **接收通知**：顾客负责接收来自水果店的通知，并根据实际情况做出响应。

按照上面的分析，我们对整个过程进行建模，得出的类图结构如下所示：
<div align="center">
   <img src="/doc/resource/observer/案例类图.png" width="60%"/>
</div>

在该类图结构中，对顾客进行了抽象，统一称呼为观察者（`Observer`），分为个人性质的顾客（`Person`）和组织性质的顾客（`Organization`）。他们都可被添加（`register()`）到水果店的通知列表中（`FruitShop#observers`），在有水果上新（`newest()`）时，将通知（`notifyObservers()`）所有关注着的顾客。在顾客接收通知（`accept()`）时，参数中包含水果店的上新内容。

# 三、代码实现
案例的实现代码如下所示。

**（1） 顾客**

**（1-1） 顾客接口**
```java
public interface Observer {

    /**
     * 获取顾客的身份信息
     * @return 身份信息
     */
    String getIdentityInfo();

    /**
     * 接收通知
     * @param info 通知内容
     */
    void accept(String info);
}
```
**（1-2） 个人顾客**
```java
public class Person implements Observer {

    private final String name;
    public Person(String name) {
        this.name = name;
    }

    @Override
    public String getIdentityInfo() {
        return name;
    }

    @Override
    public void accept(String info) {
        System.out.println(MessageFormat.format("        [{0}]接收到通知：[{1}]，回复：[{2}]",
                this.getIdentityInfo(),
                info,
                new Random().nextBoolean() ? "我不喜欢吃这些水果，下次再说" : "我马上来店里"));
    }
}
```
**（1-3） 组织性质的顾客**
```java
public class Organization implements Observer {

    private final String name;
    public Organization(String name) {
        this.name = name;
    }

    @Override
    public String getIdentityInfo() {
        return name;
    }

    @Override
    public void accept(String info) {
        System.out.println(MessageFormat.format("        [{0}]接收到通知：[{1}]，回复：[{2}]",
                this.getIdentityInfo(),
                info,
                "我马上安排员工来店里购买"));
    }
}
```
**（2）水果店**
```java
public class FruitShop {

    /**
     * 最新到货的水果
     */
    private String latestArrivalFruit;

    /**
     * 通知列表
     */
    private final Set<Observer> observers = new HashSet<>();

    /**
     * 水果上新
     * @param arrivalFruit 到货的水果
     */
    public void newest(String arrivalFruit) {
        System.out.println("    当前新到水果：" + arrivalFruit);
        this.latestArrivalFruit = arrivalFruit;
        notifyObservers();
    }

    /**
     * 顾客登记
     * @param o 顾客
     */
    public void register(Observer o) {
        System.out.println("    顾客登记：" + o.getIdentityInfo());
        this.observers.add(o);
    }

    /**
     * 顾客注销
     * @param o 顾客
     */
    public void unregister(Observer o) {
        System.out.println("    顾客注销：" + o.getIdentityInfo());
        this.observers.remove(o);
    }

    /**
     * 通知所有顾客
     */
    public void notifyObservers() {
        System.out.println("    通知所有顾客...");
        this.observers.forEach(item -> item.accept(this.latestArrivalFruit));
    }
}
```
**（3）客户端**

**（3-1）Client**
```java
public class Client {
    public static void main(String[] args) {
        System.out.println("|==> Start --------------------------------------------------------------------|");
        // 水果店
        FruitShop shop = new FruitShop();
        // 个人性质的顾客
        Person per1 = new Person("张婶");
        Person per2 = new Person("陈皮皮");
        // 组织性质的顾客
        Organization org1 = new Organization("小王面馆");
        Organization org2 = new Organization("第一街区中学食堂");
        // 登记
        shop.register(per1);
        shop.register(org1);
        shop.register(org2);
        // 上新
        shop.newest("300斤芒果，128斤榴莲");
        // 注销
        shop.unregister(org2);
        // 登记
        shop.register(per2);
        // 上新
        shop.newest("400斤香蕉，37斤菠萝蜜");
    }
}
```
**（3-1）运行结果**
```text
|==> Start --------------------------------------------------------------------|
    顾客登记：张婶
    顾客登记：小王面馆
    顾客登记：第一街区中学食堂
    当前新到水果：300斤芒果，128斤榴莲
    通知所有顾客...
        [小王面馆]接收到通知：[300斤芒果，128斤榴莲]，回复：[我马上安排员工来店里购买]
        [第一街区中学食堂]接收到通知：[300斤芒果，128斤榴莲]，回复：[我马上安排员工来店里购买]
        [张婶]接收到通知：[300斤芒果，128斤榴莲]，回复：[我不喜欢吃这些水果，下次再说]
    顾客注销：第一街区中学食堂
    顾客登记：陈皮皮
    当前新到水果：400斤香蕉，37斤菠萝蜜
    通知所有顾客...
        [小王面馆]接收到通知：[400斤香蕉，37斤菠萝蜜]，回复：[我马上安排员工来店里购买]
        [陈皮皮]接收到通知：[400斤香蕉，37斤菠萝蜜]，回复：[我不喜欢吃这些水果，下次再说]
        [张婶]接收到通知：[400斤香蕉，37斤菠萝蜜]，回复：[我马上来店里]
```

# 四、观察者模式
## 4.1 意图
> **定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。**

对观察者模式的意图解析如下：

- **对象间的一对多的依赖关系**：水果店是一类对象，接收通知的顾客是另外一类对象，水果店有多个顾客需要接收通知；
- **所有依赖的对象得到通知并被自动更新**：当水果店有上新时，顾客接收到水果店老板的通知，此时顾客可根据实际情况决定作出何种响应。

## 4.2 类图结构
观察者模式描述了一种解决方案，这种解决方案在解决不同的实际问题时，会根据不同的场景作出相应的调整。抓住思想，跳出结构，就像武侠小说里描绘的那样，武学的最高境界在于意，而非形。如果你在其他的文章中看到了不一样的类图结构，不用为类图之间的结构差别感到疑惑。
<div align="center">
   <img src="/doc/resource/observer/经典观察者模式类图.jpg" width="70%"/>
</div>

观察者模式的参与角色有如下列表：

- **Observable**：可被观察的对象接口，提供注册、注销、通知所有的观察者的行为；
- **ConcreteObservable**：可被观察的对象，内部维护一个观察者列表，当状态发生变化时，通知所有的观察者更新状态；
- **Observer**：观察者，提供更新自己状态的行为；
- **ConcreteObserver**：具体的观察者，当被通知时，可根据实际需要决定如何更新自己的状态；

# 五、深入理解
## 5.1 特点

**（1）系统耦合性更低**

对一个被观察的对象来说，他仅仅知道自己维护了一个观察者的列表，除此之外，什么也不需要知道。每个观察者都符合抽象的 Observer 类的简单接口，被观察的对象甚至不知道任何一个观察者属于哪一个具体的类。这样被观察的对象和观察者之间的耦合是最小的。 

**（2）完美支持广播的机制**

区别于通常意义上的请求，观察者模式中被观察的对象在发送通知时，不需要指定具体的接收者，这个通知会被自动广播给所有已登记在列表中的观察者。被观察的对象不需要知道有多少对象关注了自己，他只需要在状态更新后遍历通知所有的观察者。并且，这个观察者的列表是可以维护的，这给程序提供了相当大的灵活性，允许程序在任意时刻登记一个观察者或者从列表中注销一个观察者。

## 5.2 使用技巧

**（A）如何处理通知**

在观察者模式中，所强调的侧重点是被观察的重点是如何解耦的，对于观察者对象则比较弱化。但当我们将观察者模式引入到实际开发中时，复杂的往往是各个具体的观察者。这里不会对观察者有更多的讨论，但有一点需要注意。观察者该如何处理通知？答案是：根据情况合理处理通知。你可能觉得我在说废话，但我想表达的观点其实是：观察者如何处理一个通知应该根据实际情况而定，甚至需不需要对一个通知产生响应也需要考虑。不管如何，对于所有的观察者来说，肯定不会全部都按照一种方式处理消息，否则，你就需要思考是否错误的将观察者模式引入到项目中。

> 就像是案例代码中的组织性质的顾客、个人性质的顾客，对于水果上新这件事，有不同的处理方式。组织性质的顾客总是第一时间安排员工到水果店购买，但个人性质的顾客则根据当前的情况选择是否前往店里。那么，顾客是否总是需要响应通知呢？不一定，比如张婶对芒果过敏，所以，对张婶来说，如果上新的只是芒果，那么她将不会前往水果店。

**（B）显式指定感兴趣的状态改变**

前面，我们提到有时观察者不会响应某些通知，因为观察者对有些并不感兴趣。当应用中出现这类的需求时，可以考虑为观察者显示的指定感兴趣的状态。我们可以扩展注册的接口，在注册接口的参数中指定该观察者感兴趣的特定状态。这样，当被观察者对象发生状态改变事件时，我们可以根据状态是否被观察者感兴趣进行分类，在通知时，对所有观察者进行筛选，仅仅通知那些对这个状态感兴趣的观察者。

> 张婶在登记时，已明确告诉水果店老板，自己喜欢吃苹果和香蕉。往后，当水果店上新的不是这两种水果时，老板将不会打电话给张婶。

> 在 java-nio 中，注册多路复用器（Selector）到一个通道（Channel）上时，需要调用 Channel.register(Selector sel, int ops)方法。该方法的前一个参数是复用器，后一个参数就是指定感兴趣的事件。可选项有：`SelectionKey.OP_READ[1 << 0]`、`SelectionKey.OP_WRITE[1 << 2]`、`SelectionKey.OP_CONNECT[1 << 3]`和`SelectionKey.OP_ACCEPT[1 << 4]`，他们分别代表可读事件、可写事件、连接就绪事件和接收就绪事件。在使用时，我们可以通过按位或操作【`SelectionKey.OP_READ | SelectionKey.OP_WRITE`】的方式指定感兴趣的多个事件。

**（C）注意线程安全问题**

在并发情况下，应保证 注册/注销 等方法的线程安全性。这一点，不用过多阐述，这不是本章的重点，这里只从观察者列表的线程安全性这一点举例说明。

> 如果涉及到多个线程往被观察对象中注册时，应注意容器对象的线程安全问题。采用线程安全的容器来取代，比如使用 CopyOnWriteArraySet、ConcurrentHashSet、ConcurrentSkipListSet 等替换 HashSet。

**（D）存在多个被观察的对象类**

如果有多个被观察的类（ConcreteObservable），我们应该对被观察对象进行抽象，将注册、注销和通知等方法提取到抽象（Observable）中定义，就像通用的类图结构中那样。但是，实际情况是，尽管有多个被观察对象的类，他们的注册和注销等逻辑是一致的，此时我们可以使用模板类代替被观察对象接口，这样就可以实现代码重用。

**（E）推还是拉**

在观察者模式的世界中，有一个比较难以平衡的抉择 —— 推（push）还是拉（pull）？

在讨论这个问题之前，我们先了解一下，什么是推，什么是拉。所谓的推是指，在被观察的对象发生状态改变时，在通知的时候将变化的状态在参数中传递给所有观察者。比如`Observer.update(state:Object)`方法中的 state 就是变化的状态，这个过程就像是被观察的对象主动将状态变化推送到观察者。所以到目前为止，我们在文章中用的都是推的模型。那么什么又是拉模型呢？
<div align="center">
   <img src="/doc/resource/observer/观察者模式类图变种.jpg" width="60%"/>
</div>

上图就是拉模型，拉模型在收到通知后会主动向被观察对象拉取状态变化。为了满足主动拉取这一行为，我们不得不对类图结构进行调整，调整的内容我已在图中用不同的颜色区分。总体来说，改变的主要内容有增加获取状态的方法（`getState()`），观察者依赖了被观察的对象。

推模型和拉模型各有各的好处，在使用时应灵活选择，选择的标准可以从以下两个维度出发：

- **推模型更简单**：推模型中，发生状态变化时，被观察对象可以只将变化部分的状态推送给观察者对象，因为被观察对象在通知时，明确知道所有状态中哪一些发生了变化。但拉模型则没有这个优势，因为拉模型中观察者拿到的是整个 Observable，需要自行确定哪些状态发生了改变；
- **拉模型更通用**：在推模型中，需要对所有状态进行甄别，哪些是观察者关心的，这些状态发生变化时，需要触发通知机制。但如果随着需求的扩展，观察者所需的状态超出了原先约定的范围，那么就可能要对 update() 方法的定义进行调整，导致所有 Observer 的实现类跟着调整。但是拉模型则并不用担心这个问题，因为在拉模型中，每一次通知都将自身的引用传递给了观察者，已经包含了所有的状态。

## 5.3 JDK 的实现
在 jdk 中，已经提供了观察者模式的实现，他们分别是`java.util.Observer`和`java.util.Observable`。其中，Observable 就是被观察对象的模板类，已经提供了注册/注销/通知等核心方法，并且该类已经保证了线程安全。

# 附录
[回到主页](/README.md)    [案例代码](/src/main/java/com/aoligei/behavioral/observer)


