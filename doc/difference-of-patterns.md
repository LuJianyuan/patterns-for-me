## 模式区分篇
---

我们知道设计模式并不是为了介绍某种技术或者设计方法，也不会要求开发者使用某种编程技巧，因为设计模式并不立足于某种语法特性中。设计模式仅仅只是描述了在面向对象软件设计中针对于某一类问题而提出的解决方案，这些解决方法已经在前人的艰苦努力中得到充分的成功实践。

为了解决一个又一个的实际问题，前人在不断的总结和实践中为我们绘制出一幅幅的方案蓝图，蓝图中就包含了每种模式的类图结构。但不幸的是，对设计模式并不熟悉的开发者来说，有一些模式在类图结构上表现出了高度的相似性，以至于我们总是产生疑惑：这两个模式看起来差不多呀，他们究竟有何区别呢？

# 一、鉴别方法
在列举多个模式之间的区别之前，我总结了一些甄别两个模式的依据，我们可以按照这些依据尝试将两个模式区别开来。请注意，以上依据仅是我个人的经验总结，如果你对此有不同意见或者有更多的方法可以在 issue 中告诉我。

**（1）-目的是鉴别模式的唯一标准**

在前面我们提到，设计模式描述了针对于某一类特定问题而提出的解决方案，所以理解模式之前得充分融入进该模式所面临的场景。不了解实际面临的问题，即便你把该模式的内容全篇背诵下来也没有任何作用，所以我们在讨论每一个模式时，都单独提供了一小节内容来讨论意图。如果我们在学习的过程中，发现有两个模式在类图结构上表现的高度一致，目的就成了鉴别他们的唯一依据。换句话说，两个模式在解决问题的过程中，恰巧表现出来同样的类图结构，但他们的出发点却是完全不同的！

但遗憾的是，很多时候我们无法利用这一条依据准则，尤其是在阅读各种框架源码时，要猜测作者出于何种目的来组织类间关系是不容易的。如果作者使用了规范的类的命名，鉴别则变得很容易。

**（2）-规范的命名很重要**

规范的命名可以使得读者不必了解所有的类间关系就能清楚的知道代码中使用了哪一种模式。如果源码的作者在类命名时遵循了一定的规范，比如建造者类使用`Builder`结尾，策略类使用`Strategy`结尾，这会大大的提升源码的可阅读性。所以规范的命名很重要，如果你是读者，可以从规范的命名中受益，如果你是作者，也应遵循规范，以此减轻其他读者的阅读障碍。

**（3）-不同的侧重点可能隐藏着不同的细节**

尽管有些模式在结构上表现的极其相似，但这并不意味着他们一模一样，了解他们在结构上的细小差别 不仅能帮助更好的掌握他们，也是区分他们的切入点。关于这一点，在后续的模式对比中，我们将一组一组的分析。

# 二、模式鉴别
## 【2.1】组合模式vs装饰器模式
<div align="center">
   <img src="/doc/resource/difference/组合vs装饰器.png" width="60%"/>
</div>

组合模式和装饰器模式的通用类图结构如上图所示，从类图组成上看，他们均包含有抽象组件`Component`、具体组件（`ConcreteComponent`、`Leaf`）和聚合对象（`Composite`、`Decorator`）的角色。从功能上看，他们都能实现对象的递归组合。当装饰器模式中装饰器仅有一个时，我们可以省略抽象的装饰器，此时装饰器模式和组合模式的类图几乎一模一样。

尽管如此，他们还是在某些方面表现出各自的特性。从意图来看，装饰器模式依靠层层包装的机制，动态的给原始对象增加一些职责，每个装饰器对象内部仅维护一个组件（或者包装器）对象；组合模式的主要目的是为了表示部分-整体的树形关系，每一个组合对象内部均可维护多个叶子节点（或者组合对象），相较于装饰器模式来说，组合模式的侧重点是对象的聚集（比如获取子节点列表的行为`Component#getChildren()`、添加子节点的行为`Component#add(Component)`），是如何将一系列对象组织成一个树形结构，以便我们可以像处理单个对象一样来处理多个组合的对象。我们可以武断的认为装饰器模式是退化的（不注重对象的聚集）、内部仅维护一个组件的组合模式，但你必须牢记他们的出发点完全不一样。

## 【2.2】组合模式vs解释器模式

## 【2.3】中介模式vs门面模式

## 【2.4】桥模式vs抽象工厂模式

# 三、更多内容
除上述的几组模式对比之外，在每一种类型的模式总结篇中，我们列举了更多模式之间的对比情况。更多内容请访问[关于行为型模式的讨论](/doc/ending-of-behavioral-patterns.md)、[关于创建型模式的讨论](/doc/ending-of-creational-patterns.md)和[关于结构型模式的讨论](/doc/ending-of-structural-patterns.md)。


# 附录
[回到主页](/README.md)