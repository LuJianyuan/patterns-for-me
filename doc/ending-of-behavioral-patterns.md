## 关于行为型模式的讨论
---

从责任链模式开始，我们已经分别讨论了共计 11 个行为型的模式，他们分别是责任链（Chain Of Responsibility）、命令（Command）、解释器（Interpreter）、迭代器（Iterator）、中介者（Mediator）、备忘录（Memento）、观察者（Observer）、状态（State）、策略（Strategy）、模板方法（Template Method）和访问者（Visitor）模式。回顾所有的行为型模式，接下来我们将对他们进行横向对比，尝试探讨行为型模式的共性。

# 一、结构和目的

## 1.1 结构对比
<div align="center">
   <img src="/doc/resource/ending-of-behavioral/行为型模式对比图.png" width="90%"/>
</div>


行为型模式的类图结构（简化版）汇总如上图所示，接下来，让我们从类图结构的角度逐个分析。

- **责任链模式**：当我们有多个处理器都希望处理请求时，我们可以将这些处理器排列成一条处理器链，让请求沿着链路向后传递，责任链模式使得每个处理器都有机会处理请求。如此一来，每个处理器对象都有两个行为，一个是指定下一个处理器对象`Handler#setNext(Handler):void`，一个是处理请求`Handler#handleRequest():void`。正因如此，相较于其他的行为模式，责任链模式有一个独一无二的特质：处理器`Handler`对象内部维护了下一个处理器`Handler`对象，在请求处理完成时，将请求传递给下一个处理器；
- **命令模式**：命令模式着重点在于封装请求，将请求封装为一个一个的对象，这样就能解除请求调用者`Invoker`和请求处理者`Receiver`之间的耦合关系。请求由调用者`Invoker`发起，由具体的命令对象`ConcreteCommand`响应。`ConcreteCommand`大多数时间都将请求委托给处理者`Receiver`执行，但有时也可以自己处理；
- **解释器模式**：解释器模式通常用来解释并处理规则，例如 SQL 规则解释、代码解释及自定义语法解释。例如对于一个运算表达式`3+(4-1)`来说，数字为终结符表达式，而运算符`+/-`则属于非终结符表达式，因为运算符单独存在没有意义。非终结符表达式对象维护了至少一个其他表达式的引用，这样我们就能将运算表达式求解的过程拆分为一个个对象解释自身的行为过程`Expression#interpret()`；
- **迭代器模式**：有时我们希望所有的聚合对象都能提供一种方法以便对其内部结构进行遍历，但前提是不能暴露对象的内部表示，迭代器模式是不二之选。迭代器模式将对象的表示（内部元素的结构）和元素的顺序访问（遍历过程）分离开来，当我们需要遍历某个聚合对象`ConcreteAggregate`时，只需要创建一个迭代器对象`ConcreteIterator`即可，各个元素的访问顺序已经在`ConcreteIterator`内部定义好了；
- **中介者模式**：当多个对象之间的依赖关系错综复杂，对其中任何一个类的修改都将影响与之相关的多个类，此时就可以用中介者模式进行解耦。在中介者模式中，任何两个同事`ConcreteColleague`对象的协作都经过中介者`ConcreteMediator`对象的协调；
- **备忘录模式**：在对象的外部捕获这个对象的内部状态，并将其存储起来，以便在需要的时候将对象恢复为原来的状态。在备忘录模式中，原发器`Originator`负责创建一个备忘录`Memento`对象，并存储在负责人`CareTaker`中，在需要的时候，从负责人`CareTaker`处取出一个备忘录对象，依据该备忘录，原发器`Originator`可将自身的状态回滚到之前的某个版本；
- **观察者模式**：观察者模式定义了一种一对多的依赖关系，一个被观察者`Observable`对象内部维护了多个观察者`Observer`对象，当被观察者对象的状态发生变化时，告知所有的观察者对象，观察者对象根据自身情况决定如何处理被观察者状态的变化。观察者模式反转了依赖关系，使得通知的机制深入人心；
- **状态模式**：就像是内在情绪和外在表现之间的关系一般，状态模式为我们描绘了该如何处理对象在不同的状态时表现出了不同的行为。状态模式客户端提供了统一的接口`Context#request()`，`Context`中维持了对象当前所处的状态`State`，并且当客户端的请求处理完成后可能将切换到下一个状态。而不同的状态`ConcreteState`表现出不同的行为，这样就实现了同一个对象提供的同一个接口`Context#request()`，在不同的状态下呈现出了不同的行为`ConcreteState#handle()`；
- **策略模式**：定义不同的算法`ConcreteStrategy`，将他们封装起来，并且使得他们可以相互替换（都实现自`Strategy`抽象）。这样客户端就能使用不同的算法`ConcreteStrategy`来装配`Context`对象，并且`Strategy`和`Context`之间互相独立，各自变化；
- **模板方法模式**：有时候一些操作有相似的算法骨架，区别在于算法中的某些步骤表现出不同的行为。模板方法模式通过在父类中定义算法骨架`AbstractClass#templateMethod()`，对于可变的步骤`AbstractClass#abstractMethod1()`、`AbstractClass#abstractMethod2()`交给子类实现，这样就能不改变算法的结构但改变了某些特定步骤的行为；
- **访问者模式**：我们让一个复杂聚合对象`ObjectStructure`中的每一个元素都提供一个访问自身的行为`Element#accept(Visitor)`，访问器`Visitor`内部包装了针对于所有元素`ConcreteElement`的不同操作方式。这样我们就可以通过扩展新的访问器`ConcreteVisitor`来实现作用于已有元素的新操作；

## 1.2 目的对比
接下来，让我们再回顾一下所有行为型模式的意图。

- **责任链模式**：_使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止；_
- **命令模式**：_将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作；_
- **解释器模式**：_给定一种语言， 定义它的文法的一种表示 ，以及一个解释器，这个解释器使用这个表示来解释该语言中的句子；_
- **迭代器模式**：_提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示；_
- **中介者模式**：_用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互；_
- **备忘录模式**：_在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态；_
- **观察者模式**：_定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新；_
- **状态模式**：_允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类；_
- **策略模式**：_定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化；_
- **模板方法模式**：_定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤；_
- **访问者模式**：_表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。_

## 1.3 易混淆的模式
从结构上来看，大部分行为型模式呈现出了较大的差异性，但其中也不乏一些特例。

**（1）解释器 vs 组合**

相信眼尖的你已经发现：解释器模式和结构型模式中的组合模式在结构上几乎如出一辙。尽管他们的结构几乎完全一致，但他们的目的却完全不同，解释器模式将一个完整的表达式的求解过程拆分到一个个简单的解释器对象中，通过这些简单的对象便能完成求解。当然在这个过程中必然牵涉到上下文环境，例如`x+y`这样的的一个表达式，对于表示符号`+`的`NonterminalExpression`对象来说，必定维护了一个表示`x`的表达式引用和一个表示`y`的表达式引用，而他只需要完成前后两部分最终值的求和即可。正如我们在解释器模式一章中所说，一个完整的表达式最终会被解析成为一个抽象语法树对象，从结果上来讲，这些简单的解释器对象在无疑之中就组成了一个树形结构。巧的是，组合模式刚好就能表示树形结构，从结构上看，终结符呈现了叶子节点的特性，非终结符则扮演了复合节点的角色，所以他们的结构才会如此的相像。注意本章节的重点是关于行为型模式的讨论，由于组合模式不属于行为型模式，所以关于解释器模式和组合模式更全面的对比，我们将在模式对比篇中深入讨论。

**（2）状态 vs 策略**

另外一组相似的模式是状态模式和策略模式，单从类图结构上，我们似乎无法区分他们，因为他们的结构表现的高度一致。对于结构相似的模式，我们应该从出发点和目的加以区别。状态模式强调的是对象在不同的状态下表现出不同的行为，而策略模式则是希望算法能够独立于使用它的客户，他们在动机不一样。

对于策略模式来说，环境对象表现出什么样的行为`Context#contextInterface()`取决于使用什么样的策略`ConcreteStrategy`，而策略是由客户端指定的；状态模式则不一样，在状态模式中，环境对象的行为`Context#request()`与当前的状态`ConcreteState`息息相关，而状态是在环境内部进行转换的，客户端的每一次请求都可能引起内部状态的装换，但客户端对此没有感知。

各个策略彼此之间没有关系，理论上这些策略可以相互替换；但各个状态之间可能有连接关系，因为有些情况下，一个状态可能会转换成另一个状态，这就意味着该状态至少知道一个其他的状态。正因为如此，策略模式对客户端来说更加透明，因为客户端需要根据每种策略的特点选择最合适的；而状态模式对客户端来说更加简单，因为客户端不用感知到状态的变化。

# 二、行为型模式的主旋律
在关于结构型模式的讨论中，我们对于结构型模式和行为型模式的分类原则做了大致的分析，并且挨个分析了为什么属于结构型模型。在前面我们已经说了，行为型模式把关注点放在行为上，关注类或者对象之间该如何交互与通信，该如何划分职责。所有行为型模式都围绕着几个主旋律展开，这几个主旋律是封装变化、对象入参和对请求解耦。

## 2.1 封装变化
当一个系统在某个方面经常发生变化时，我们通常需要对这个方面进行封装。例如

- 策略模式是对算法的封装，一个`Strategy`对象就封装了一个具体的算法；
- 状态模式是对状态的封装，一个`State`对象封装了一些与状态相关的行为；
- 中介者模式是对通信协议的封装，一个`Mediator`对象封装了其他对象之间通信所必须遵守的协议；
- 迭代器模式是对遍历过程的封装，一个`Iterator`对象封装了访问一个聚合对象的各个元素的方法；
- 访问者模式是对元素操作的封装，一个`Visitor`对象封装了如何访问一批元素中的每一个；

## 2.2 对象入参

有一些行为模式总是定义可被作为参数使用的对象，以此来屏蔽复杂的内部细节或者让参数具有更广的扩展性。例如

- 访问者模式通常让元素接收一个`Visitor`对象作为参数（`Element#accept(Visitor)`），这个`Visitor`对象作用于元素本身，代表了对于该元素对象所进行的操作；
- 在命令模式中，`Command`对象代表了一个请求，该`Command`对象被当做参数传递给`Invoker`对象，并在稍后将被调用（`Invoker#doCommand()`）；
- 在备忘录模式中，`Memento`对象代表了原始对象`Originator`在某个时刻的内部状态，该`Memento`对象在需要的时候作为参数传递给原始对象以恢复状态（`Originator#setMemento(Memento)`）；

## 2.3 对请求解耦

当合作的对象直接互相引用时，他们之间会变得互相依赖，这在一定程度上影响了对象的重用性。这个时候，我们需要对请求过程进行解耦。命令、观察者、中介者和责任链模式都涉及到如何应对请求发送者和请求接收者之间的耦合关系，但他们又有着各自独立的考虑角度。

命令模式使用一个`Command`对象来定义一个发送者和一个接收者之间的绑定关系。这样使得一个发送者`Invoker`可以和多个不同的接收者`Receiver`在一起工作，这样就解除了接收者和发送者之间的耦合关系，使得发送者更易于复用。命令模式的工作过程如下图所示。
<div align="center">
   <img src="/doc/resource/ending-of-behavioral/命令模式请求时序图.svg" width="60%"/>
</div>

观察者模式通过定义一个接口`Observer#update()`来通知目标对象发生的变化，从而将发送者`Observable`和接收者`Observer`解耦。观察者模式的工作过程如下所示。
<div align="center">
   <img src="/doc/resource/ending-of-behavioral/观察者模式请求时序图.svg" width="60%"/>
</div>

中介者模式提供一个中介对象`Mediator`，让请求发送者`Colleague1`和请求接收者`Colleague2`之间不再直接交互。这样发送者和接收者之间便没有了依赖关系，所有的请求都经过中介对象的路由分发给相应的接收者。中介者模式的工作过程如下所示。
<div align="center">
   <img src="/doc/resource/ending-of-behavioral/中介者模式请求时序图.svg" width="40%"/>
</div>

责任链模式则通过沿着一个接收者对象链路传递请求，间接的实现了请求发送者`Client`和请求接收者`ConcreteHandler`之间的解耦。责任链模式的工作过程如下所示。
<div align="center">
   <img src="/doc/resource/ending-of-behavioral/责任链模式请求时序图.svg" width="70%"/>
</div>


# 附录
[回到主页](/README.md)